# 并发编程边角料

## 当我们谈论并发编程时,不可避免地.我们想到多线程,线程池,io多路复用,条件变量等等.今天我想分享的是一些边角的知识,帮助我们在编写并发程序时进行取舍.

之所以将题目定为**边角料**,是因为接下来你将看到下面列出的一些操作时间在几十到几万时钟周期(ns 到 us 数量级).而网络编程中,一个阻塞的socket,阻塞查询数据库,读取文件等所需时间可能会到毫秒甚至秒级,此时对上述的边角料的优化都是徒劳的.

## 并发的代价

进程创建,销毁,切换,轮询的代价

1. <img src="D:\working\treasureChest\linux\并发编程边角料\2022-04-21-18-19-10-CreateThread.png" style="zoom:200%;" />

2. <img src="D:\working\treasureChest\linux\并发编程边角料\2022-04-21-18-21-41-CreateProcess.png" style="zoom:200%;" />

3. # <img src="D:\working\treasureChest\linux\并发编程边角料\2022-04-21-18-22-03-LaunchProgram.png" title="" alt="" width="603" style="zoom:200%;" >

**注**: launch program指 fork()+exec()

4. ![](D:\working\treasureChest\linux\并发编程边角料\2022-04-21-18-37-09-image.png)

5. ![](D:\working\treasureChest\linux\并发编程边角料\2022-04-21-18-39-11-fa4a22a07faeddab47b562fb91eb04a9.png)

Conclusion

线程进程创建,上下文切换时间都在10us级别.这在普遍情况下都是不大的.

*benchmark*:

https://www.bitsnbites.eu/benchmarking-os-primitives/

[Cost of a thread in C++ under Linux &#8211; Daniel Lemire&#039;s blog](https://lemire.me/blog/2020/01/30/cost-of-a-thread-in-c-under-linux/)

[Tsuna's blog: How long does it take to make a context switch?](https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html)

https://zhuanlan.zhihu.com/p/79772089

https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/

## 考虑一个并发服务器的架构

现在我们想写一个echo服务器.可以容易地想到这些做法:

1. 一个主循环,一个接一个的处理socket连接

```cpp
while(1){
    conn_fd = accept();
    while(1){
    read();
    write();
    if(error || eof){
         break;
        }
    }
}
```

每一个调用都是阻塞的,其中一些可能会阻塞几十秒.一个服务器同一时间只能处理一个连接.

2. 一个主循环,为每一个连接创建一个线程

```cpp
while(1){
    conn_fd = accept();
    create_thread(handle_request,conn_fd);
}
```

用同步的方式写并发程序,逻辑十分清晰.在只有几十几百个并发连接的时候是没有问题的.

或者可以用一个线程池,和一个带条件变量的有界队列.主线程将连接放入队列,唤醒线程池中的线程取走任务.这样可以减少线程创建和销毁的消耗.

3. io复用
   
   ```cpp
      eventloop loop;
     loop.register(connectcallback);
     loop.register(messagecallbcak);
     loop.register(writecallback);
      
      loop.run();
   ```

异步网络编程(reactor,proactor)思路是声明一个事件循环用来等待epoll(poll)返回 ,注册socket连接可读可写等回调事件.

当条件满足时eventloop调用回调函数.这种模式的优点是可以管理大量的socket长连接(不必为了一个长连接长时间占用一个线程).

但是这种模式也有明显的缺点.代码逻辑散落在一个个回调函数中.而且函数间调用顺序是不确定的,很难debug.异步编程中连接(TcpConnection)的所有权要在回调函数中传递.对象(TcoConnection)的生命周期(**内存由谁申请,由谁释放,什么时候释放,怎么释放**)在一些没有gc的语言中是个令人困惑的问题,一不小心就会内存泄漏.在一些时候,找到合适的错误抛出时机也很难.

<mark>注</mark>:现代cpp发扬了RAII(Resouce Acquisition Is Initialization,资源获取即初始化)原则,shardptr,uniqueptr等智能指针的出现解决了很大一部分问题.但是sharedptr还是有race condition和 shard_from_this(对象成员函数获取本对象的智能指针)等问题.

4. 如果有一种办法可以用同步方式编写并发程序,在异步调用时自动切换上下文让出cpu,那它的名字就叫做协程.

# 协程初探

我们想要解决的事情:

1. 更轻量级的创建销毁切换协程

2. io阻塞时能自动切换

协程在本质上就是在用户态层面,在合适的时候切换上下文,这样省下一大笔系统调用的耗费.

现在我们想实现一个协程,首先考虑以下这些事情:

1. 协程传递机制,协程挂起时将所有权传递给协程的调用者(协程的管理者),让其进行协程调度.还是设计一种算法,让控制权在协程间直接传递.这样分别划分了非对称协程和对称协程两种概念.
2. 协程有无栈.是否允许协程在嵌套的函数中挂起(这意味着必须在挂起时一路向下保存函数栈帧).无栈协程只能在函数顶层挂起.这样划分了有栈协程和无栈协程两种概念.

![preview](D:\working\treasureChest\linux\并发编程边角料\v2-039d97b92f66e84801938c0e4b63e7cf_r.jpg)

**info**:作为拓展,可以思考以下问题

1. 在一些有指针语义的语言,如c/c++等,无栈协程切换过后时可能会改变堆栈指针位置,这是如果出现了栈上变量的指针操作很大概率上会引起程序崩溃.

![https://upload.wikimedia.org/wikipedia/commons/thumb/d/d3/Call_stack_layout.svg/342px-Call_stack_layout.svg.png](D:\working\treasureChest\linux\并发编程边角料\342px-Call_stack_layout.svg.png)

1. 有栈协程中,为每个协程分配多少栈空间合适呢?大了浪费,小了不够用.而且非共享栈情况下协程栈空间不能随便扩容(原因和上一条一样,会引发指针崩溃)

## 从代码的角度查看协程实现

下面是[云风的协程实现](https://github.com/cloudwu/coroutine/blob/master/coroutine.c)(代码行数不超过300,主要是用到了linux切换上下文的setcontext系统调用,也没有hook linux的系统io调用)

**这是一个非对称的有栈协程**

```c
//协程调度器结构体
struct schedule {
    char stack[STACK_SIZE];    // 运行时栈，此栈即是共享栈
    ucontext_t main; // 主协程的上下文
    int nco;        // 当前存活的协程个数
    int cap;        // 协程管理器的当前最大容量，即可以同时支持多少个协程。如果不够了，则进行 2 倍扩容
    int running;    // 正在运行的协程 ID
    struct coroutine **co; // 一个一维数组，用于存放所有协程。其长度等于cap
};

// 协程结构体
struct coroutine {
    coroutine_func func; // 协程所用的函数
    void *ud;  // 协程参数
    ucontext_t ctx; // 协程上下文
    struct schedule * sch; // 该协程所属的调度器
    ptrdiff_t cap;      // 已经分配的内存大小
    ptrdiff_t size; // 当前协程运行时栈，保存起来后的大小
    int status;    // 协程当前的状态
    char *stack; // 当前协程的保存起来的运行时栈
};
```

可以看见他在结构体里保存了协程所需要的所有信息.现在只需要协程让出执行权限(yield)和恢复协程(resume)两个最重要的操作.

```c
coroutine_yield(struct schedule * S) {
    int id = S->running;
    struct coroutine * C = S->co[id];
    _save_stack(C,S->stack + STACK_SIZE); //保存调用栈
    swapcontext(&C->ctx , &S->main); //交换上下文
}

_save_stack(struct coroutine *C, char *top) {
    char dummy = 0;
    ... //省略了动态扩容,错误检查逻辑
    C->size = top - &dummy;
    memcpy(C->stack, &dummy, C->size);
} //本函数主要作用就是将协程栈复制到协程结构体信息体中




coroutine_resume(struct schedule * S, int id) {
    struct coroutine *C = S->co[id]; //获取协程信息
        ... //省略一些逻辑
        getcontext(&C->ctx);
        C->ctx.uc_stack.ss_sp = S->stack; //设置协程运行栈为共享栈
        C->ctx.uc_stack.ss_size = STACK_SIZE;
        C->ctx.uc_link = &S->main; //设置协程执行完后切换回main协程
        S->running = id;
        C->status = COROUTINE_RUNNING;
        uintptr_t ptr = (uintptr_t)S;
        makecontext(&C->ctx, (void (*)(void)) mainfunc, 2, (uint32_t)ptr, (uint32_t)(ptr>>32)); //将 C->ctx 的执行函数体设置为了 mainfunc。
        swapcontext(&S->main, &C->ctx); // 将当前的上下文放入 S->main 中，并将 C->ctx 的上下文替换到当前上下文
        ....
}
```

**注**: 云风的协程主要用到了共享栈.即多个协程使用同一个栈空间.在yield时将共享栈空间内容复制到coroutine结构体中.resume时再将其复制回共享栈.这样做的主要考虑是协程栈大小不确定,如果每次都分配一个固定大小的栈会造成空间浪费和栈大小不足等情况.

这样一个协程就基本完成了.但是离好用还差得有点多.没有实现系统调用的hook,只能自己手动注册resume函数,例如:

```c++
  asyn_func(function(){
        coroutine.resume(co)
  }); //注册回调,异步操作完成后就切换回此协程继续执行
  coroutine.yield();
```

如果有兴趣可以去看看更多的协程实现.比如微信的libco(完成了阻塞io自动切换,定时器,协程间通信,嵌套协程).就目前来看,好用的协程还得看goroutine  :) . 

**注**:libco 对系统io调用的改造也是通过epoll注册回调实现的.

<img src="D:\working\treasureChest\linux\并发编程边角料\2022-04-23-21-01-26-v2-653fece19620f51d8bb38385df2132ef_r.jpg" title="" alt="" width="709" style="zoom:200%;" >

conclusion:

现代的语言基本都会对异步io有一套应对办法.目前来看在协程中,还是golang的goroutine 原生的语言支持更加有生命力.



## reference:

[c++ stack frame](https://stackoverflow.com/questions/1395591/what-is-exactly-the-base-pointer-and-stack-pointer-to-what-do-they-point)

[difference between asymmetric and symmetric coroutines](https://stackoverflow.com/questions/41891989/what-is-the-difference-between-asymmetric-and-symmetric-coroutines)

[paper:revisiting coroutines](http://www.inf.puc-rio.br/~roberto/docs/MCC15-04.pdf)

[云风协程库](https://github.com/cloudwu/coroutine/)

[libco](https://github.com/Tencent/libco)

[ucontext](https://github.com/zfengzhen/Blog/blob/master/article/ucontext%E7%B0%87%E5%87%BD%E6%95%B0%E5%AD%A6%E4%B9%A0.md)

