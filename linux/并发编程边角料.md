# 并发编程边角料

当我们谈论并发编程时,不可避免地.我们想到多线程,多路复用,条件变量,线程池等等.今天我想分享的是一些我们需要知道的知识,帮助我们在编写并发程序时的取舍.

之所以将题目定为**边角料**,是因为接下来你将看到下面列出的一些操作时间在几十到几万时钟周期(ns 到 us 数量级).而网络编程中,一个阻塞的socket,阻塞查询数据库,读取文件等所需时间可能会到毫秒甚至秒级,此时对上述的边角料的优化都是徒劳的.

## 并发的代价

进程创建,销毁,切换,轮询的代价

1. ![](C:\Users\zlf\AppData\Roaming\marktext\images\2022-04-21-18-19-10-CreateThread.png)

2. ![](C:\Users\zlf\AppData\Roaming\marktext\images\2022-04-21-18-21-41-CreateProcess.png)

3. <img src="file:///C:/Users/zlf/AppData/Roaming/marktext/images/2022-04-21-18-22-03-LaunchProgram.png" title="" alt="" width="603">

注: launch program指 fork()+exec()

4. ![](C:\Users\zlf\AppData\Roaming\marktext\images\2022-04-21-18-37-09-image.png)

5. ![](C:\Users\zlf\AppData\Roaming\marktext\images\2022-04-21-18-39-11-fa4a22a07faeddab47b562fb91eb04a9.png)



Conclusion

线程进程创建,上下文切换时间都在10us级别.这在普遍情况下都是不大的.

*benchmark*:

https://www.bitsnbites.eu/benchmarking-os-primitives/

[Cost of a thread in C++ under Linux &#8211; Daniel Lemire&#039;s blog](https://lemire.me/blog/2020/01/30/cost-of-a-thread-in-c-under-linux/)

[Tsuna's blog: How long does it take to make a context switch?](https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html)

https://zhuanlan.zhihu.com/p/79772089

https://eli.thegreenplace.net/2018/measuring-context-switching-and-memory-overheads-for-linux-threads/

## 考虑一个并发服务器的架构

现在我们想写一个echo服务器.可以容易地想到这些做法:

1. 一个主循环,一个一个的处理socket连接

```cpp
while(1){
    conn_fd = accept();
    while(1){
    read_all;
    write_all;
    if(error){
         break;
        }
    }
}
```

每一个调用都是阻塞的,其中一些可能会阻塞几十秒.一个服务器同一时间只能处理一个连接.

2. 一个主循环,为每一个连接创建一个线程

```cpp
while(1){
    conn_fd = accept();
    create_thread(thread,conn_fd);
}
```

用同步的方式写并发程序,逻辑十分清晰.在只有几百个并发连接的时候是没有问题的

可以用一个线程池,和一个带条件变量的有界队列.主线程将连接放入队列,唤醒线程池中的线程取走任务.这样可以减少线程创建和销毁的消耗.

3. io复用
   
   ```cpp
      eventloop loop;
     loop.register(connectcallback);
     loop.register(messagecallbcak);
     loop.register(writecallback);
   ```

异步网络编程(reactor,proactor)思路是声明一个事件循环用来等待epoll(poll)返回 ,注册socket连接可读可写等回调事件.

当条件满足时eventloop调用回调函数.这种模式的优点是可以管理大量的socket长连接(不必为了一个长连接长时间占用一个线程).

但是这种模式也有明显的缺点.代码逻辑散落在一个个回调函数中.而且函数间调用顺序是不确定的.很难debug.异步编程中连接的所有权要在回调函数中传递.对象的生命周期(**内存由谁申请,由谁释放,什么时候释放,怎么释放**)在一些没有gc的语言中问题尤为严重.一不小心就会内存泄漏.



注:现代cpp发扬了RAII(Resouce Acquisition Is Initialization，翻译成中文的意思就是资源获取即初始化)原则,shardptr,uniqueptr等智能指针的出现解决了很大一部分问题.但是sharedptr还是有race condition和 shard_from_this(对象成员函数获取本对象的智能指针)等问题.



4. 如果有一种办法可以用同步方式编写并发程序,在异步调用时自动切换上下文让出cpu,那它的名字就叫做协程.

5. 


