# Go并发

## 并发原理

Go 语言运行时会在底层通过调度器将用户级线程交给操作系统的系统级线程去处理，如果在运行过程中遇到某个 IO 操作而暂停运行，调度器会将用户级线程和系统级线程分离，以便让系统级线程去处理其他用户级线程，而当 IO 操作完成，需要恢复运行，调度器又会调度空闲的系统级线程来处理这个用户级线程，从而达到并发处理多个协程的目的。

## 并发通信

### 加锁

```go
import (
    "sync"
)

lock.Lock()
    counter++
    lock.Unlock()
```

### channel

通道类型变量只支持发送和接收操作，即往通道中写入数据和从通道中读取数据，对应的操作符都是 `<-`，我们判断是发送还是接收操作的依据是通道类型变量位于 `<-` 左侧还是右侧，位于左侧是发送操作，位于右侧是接收操作：

```go
x := <- ch     // 从通道中读取数据并赋值给变量ch <- 1  
```

**将数据发送到通道时，发送的是数据的副本，同理，从通道中接收数据时，接收的也是数据的副本。**

