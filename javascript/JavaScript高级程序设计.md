---
title: JavaScript高级程序设计
date: 2021-09-21 00:35:59
tags: 
  - web开发
  - JavaScript
categories:
  - [术,JavaScript]
---

# JavaScript高级程序设计

## 1-js基础

### 1-1HTML中使用JavaScript

把JavaScript插入到HTML页面中要使用 \\<\script\> 元素。使用这个元素可以
把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含
外部的JavaScript文件。而我们需要注意的地方有：

● 在包含外部JavaScript文件时，必须将 src 属性设置为指向相应文件的
URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文
件，也可以是其他任何域中的文件。

● 所有 \\<\script\> 元素都会按照它们在页面中出现的先后顺序依次被解
析。 在 不 使 用 defer 和 async 属 性 的 情 况 下， 只 有 在 解 析 完 前
面 <\script> 元素中的代码之后，才会开始解析后面 <\script> 元素中的
代码。

● 由于浏览器会先解析完不使用 defer 属性的 \<\script\> 元素中的代码，
然后再解析后面的内容，所以一般应该把 \<\script\> 元素放在页面最
后，即主要内容后面， \<\/body\> 标签前面。

● 使用 defer 属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是
按照指定它们的顺序执行。

● 使用 async 属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档
呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。

另外，使用 \\<noscript\> 元素可以指定在不支持脚本的浏览器中显示的替代
内容。但在启用了脚本的情况下，浏览器不会显示\\ <\\noscript\\> 元素中的任
何内容。

### 1-2基本语法

#### 严格模式

ECMAScript 5引入了严格模式（strict mode）的概念。严格模式是为
JavaScript 定 义 了 一 种 不 同 的 解 析 与 执 行 模 型。 在 严 格 模 式 下，
ECMAScript 3中的一些不确定的行为将得到处理，而且对某些不安全的操
作也会抛出错误。要在整个脚本中启用严格模式，可以在顶部添加如下代
码：

```
"use strict";
```

#### 变量

```JavaScript
var message;
```

这行代码定义了一个名为 message 的变量，该变量可以用来保存任何值（像
这样未经过初始化的变量，会保存一个特殊的值—— undefined 

### 1-3数据类型

ECMAScript 中 有 5 种 简 单 数 据 类 型 （也 称 为 基 本 数 据 类
型）： Undefined 、 Null 、 Boolean 、 Number 和 String 。还有1种复杂数据类
型—— Object ， Object 本质上是由一组无序的名值对组成的。

#### typeof

对一个值使
用 typeof 操作符可能返回下列某个字符串：
● "undefined" ——如果这个值未定义；
● "boolean" ——如果这个值是布尔值；
● "string" ——如果这个值是字符串；
● "number" ——如果这个值是数值；
● "object" ——如果这个值是对象或 null ；
● "function" ——如果这个值是函数。

>  typeof 操作符会返回一些令人迷惑但技术上却正确的值。比
> 如，调用 typeof null 会返回 "object" ，因为特殊值 null 被认为是一个空
> 的对象引用

>  对 未 初 始 化 和 未 声 明 的 变 量 执 行 typeof 操 作 符 都 返 回
> 了 undefined 值；这个结果有其逻辑上的合理性。因为虽然这两种变量从技
> 术角度看有本质区别，但实际上无论对哪种变量也不可能执行真正的操
> 作。



从逻辑角度来看， null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回 "object" 的原因，

```JavaScript
var car = null;
alert(typeof car); // "object"
```

实际上， undefined 值是派生自 null 值的，因此ECMA-262规定对它们的相
等性测试要返回 true ：

```JavaScript
alert(null == undefined); //true
```

#### 浮点数

浮点数值的最高精度是17位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1加0.2的结果不是0.3，而是0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。例如：

```JavaScript
if (a + b == 0.3){ // 不要做这样的测试！
alert("You got 0.3.");
}
```

在这个例子中，我们测试的是两个数的和是不是等于0.3。如果这两个数是0.05和0.25，或者是0.15和0.15都不会有问题。而如前所述，如果这两个数是0.1和0.2，那么测试将无法通过。因此，永远不要测试某个特定的浮点数值。

#### NaN

NaN ，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一
个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误
了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止
代码执行。但在ECMAScript中，任何数值除以0会返回 NaN ，因此不会影响
其他代码的执行。

NaN 本 身 有 两 个 非 同 寻 常 的 特 点。 首 先， 任 何 涉 及 NaN 的 操 作 （例如 NaN /10）都会返回 NaN ，这个特点在多步计算中有可能导致问题。其次， NaN 与任何值都不相等，包括 NaN 本身。例如，下面的代码会返回 false ：

```JavaScript
alert(NaN == NaN); 
```

#### String

> ECMAScript中的字符串是不可变的，也就是说，字符串一旦创建，它们的
> 值就不能改变。要改变某个变量保存的字符串，首先要销毁原来的字符
> 串，然后再用另一个包含新值的字符串填充该变量

#### object

### 1-4操作符

#### +

如果有一个操作数是 NaN ，则结果是 NaN ；
● 如果是 Infinity 加 Infinity ，则结果是 Infinity ；
● 如果是 -Infinity 加 -Infinity ，则结果是 -Infinity ；
● 如果是 Infinity 加 -Infinity ，则结果是 NaN ；
● 如果是+0加+0，则结果是+0；
● 如果是-0加-0，则结果是-0；
● 如果是+0加-0，则结果是+0。

#### 相等操作符

##### ==

> ECMAScript中的相等操作符由两个等于号（ == ）表示，如果两个操作数相
> 等，则返回 true 。而不相等操作符由叹号后跟等于号（ != ）表示，如果两
> 个操作数不相等，则返回 true 。这两个操作符都会先转换操作数（通常称
> 为强制转型），然后再比较它们的相等性。

在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：

如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值—— false 转换为0，而 true 转换为1；
● 如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；
● 如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法，用得到的基本类型值按照前面的规则进行比较；这两个操作符在进行比较时则要遵循下列规则。
● null 和 undefined 是相等的。
● 要比较相等性之前，不能将 null 和 undefined 转换成其他任何值。
● 如果有一个操作数是 NaN ，则相等操作符返回 false ，而不相等操作符返回 true 。重要提示：即使两个操作数都是 NaN ，相等操作符也返回 false ；因为按照规则， NaN 不等于 NaN 。
● **如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回 true ；否则，返回 false 。**

##### ===

除了在比较之前不转换操作数之外，全等和不全等操作符与相等和不相等
操作符没有什么区别。全等操作符由3个等于号（ === ）表示，它只在两个
操作数未经转换就相等的情况下返回 true 

### 1-5控制语句

### 1-6函数

#### 参数

ECMAScript中的参
数在内部是用一个数组来表示的。实际上，在函数体内可以通过 arguments 对象来访问这个参数数组，从而获取传递给函数的每一个参数。

### 1-7总结

ECMAScript 中 的 基 本 数 据 类 型 包
括 Undefined 、 Null 、 Boolean 、 Number 和 String 。
● 与其他语言不同，ECMScript没有为整数和浮点数值分别定义不同的
数据类型， Number 类型可用于表示所有数值。
● **ECMAScript中也有一种复杂的数据类型，即Object类型，该类型是这**
**门语言中所有对象的基础类型。**
● 严格模式为这门语言中容易出错的地方施加了限制。
● ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包
括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符
等。
● ECMAScript从其他语言中借鉴了很多流控制语句，例如 if 语句、 for
语句和 switch 语句等。

● 无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。
● 实际上，未指定返回值的函数返回的是一个特殊的 undefined 值。
● ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含
零或多个值的数组的形式传递的。
● 可 以 向 ECMAScript 函 数 传 递 任 意 数 量 的 参 数， 并 且 可 以 通
过 arguments 对象来访问这些参数。
● 由于不存在函数签名的特性，ECMAScript函数不能重载。

## 2-js进阶

### 2-1变量,作用域,内存

#### 变量

> 在将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类
> 型 值。 第 3 章 讨 论 了 5 种 基 本 数 据 类
> 型： Undefined 、 Null 、 Boolean 、 Number 和 String 。这5种基本数据类型是
> 按值访问的，因为可以操作保存在变量中的实际的值。
> 引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许
> 直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作
> 对象时，实际上是在操作对象的引用而不是实际的对象。为此，引用类型
> 的值是按引用访问的。

#### 赋值

> 对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副
> 本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作
> 结束后，两个变量实际上将引用同一个对象。因此，改变其中一个变量，
> 就会影响另一个变量

**作为函数参数传递时,对象变量传值进去,但因为对象变量保存的是对象实体的内存地址,在函数里改变对象在函数外部也能反映出来**

#### 执行环境

> 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope
> chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即 arguments 对（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。

#### 垃圾搜集

JavaScript采用**标记回收**

JavaScript中最常用的垃圾收集方式是标记清除（mark-and-sweep）。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。

#### 性能

> 优化内存占用的最佳方式，就是为执行中的代码只保存必要的数据。一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）

### 2-2引用类型

#### Array类型

**array.length 不是只读的**

```javascript
var colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组
colors.length = 2;
alert(colors[2]); //undefined
```

> ECMAScript 5新增了 Array.isArray() 方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的。

##### 转换方法

所有对象都具有 toLocaleString() 、 toString() 和 valueOf()方法。其中，调用数组的 toString() 和 valueOf() 方法会返回相同的值，即由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串

```JavaScript
var colors = ["red", "blue", "green"]; // 创建一个包含3个字符串的数组
alert(colors.toString()); // red,blue,green
alert(colors.valueOf()); // red,blue,green
alert(colors); // red,blue,green
```

##### 迭代方法

● every() ：对数组中的每一项运行给定函数，如果该函数对每一项都返
回 true ，则返回 true 。
● filter() ：对数组中的每一项运行给定函数，返回该函数会返回 true
的项组成的数组。
● forEach() ：对数组中的每一项运行给定函数。这个方法没有返回值。
● map() ：对数组中的每一项运行给定函数，返回每次函数调用的结果组
成的数组。
● some() ：对数组中的每一项运行给定函数，如果该函数对任一项返
回 true ，则返回 true 。

#### RegExp

正则表达式

#### Function类型

**函数实际上是对象。每个函数都是 Function 类型的实例，而且都与其他引用类型一样具有属性和方法**

> 解析器在向执行环境中加载数据时，对函数声明和函数表达式并非一视同仁。解析器会率先读取函数声明，并使其在执行任何代码之前可用(可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释行

```JavaScript
alert(sum(10,10));
function sum(num1, num2){
return num1 + num2;
}
//可以执行因为在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部。所以，即使声明函数的代码在调用它的代码后面，JavaScript引擎也能把函数声明提升到顶部。

alert(sum(10,10));
var sum = function(num1, num2){
return num1 + num2;
};

//以上代码之所以会在运行期间产生错误，原因在于函数位于一个初始化语句中，而不是一个函数声明。换句话说，在执行到函数所在的语句之前，变量 sum 中不会保存有对函数的引用；

```

##### 函数内部属性

